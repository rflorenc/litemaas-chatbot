# Makefile for Open Source Mentor Bot

# Determine which compose and container command to use
COMPOSE_CMD := $(shell command -v podman-compose 2> /dev/null || command -v docker-compose 2> /dev/null)
CONTAINER_CMD := $(shell command -v podman 2> /dev/null || command -v docker 2> /dev/null)

# Check if .env file exists
ENV_FILE := .env
ENV_CHECK := $(shell test -f $(ENV_FILE) && echo "exists" || echo "missing")

# Load environment variables from .env if it exists
ifneq ($(ENV_CHECK),missing)
    include .env
    export
endif

.PHONY: help setup env venv install build up down restart logs clean shell test lint format health push login dev build-run \
	oc-help oc-check oc-deploy oc-clean oc-rebuild oc-status oc-logs oc-shell oc-url oc-verify oc-build oc-restart oc-scale \
	helm-help helm-check helm-lint helm-template helm-install helm-upgrade helm-uninstall helm-test helm-list helm-status helm-get-values

# Default target
help:
	@echo "Open Source Mentor Bot - Makefile Commands"
	@echo ""
	@echo "Setup & Environment:"
	@echo "  make setup       - Initial setup (create .env, venv)"
	@echo "  make env         - Create .env from template"
	@echo "  make venv        - Create Python virtual environment"
	@echo "  make install     - Install Python dependencies in venv"
	@echo ""
	@echo "Container Operations:"
	@echo "  make build       - Build container image"
	@echo "  make up          - Start container"
	@echo "  make down        - Stop container"
	@echo "  make restart     - Restart container"
	@echo "  make logs        - Show container logs"
	@echo "  make shell       - Open shell in container"
	@echo "  make health      - Check container health"
	@echo ""
	@echo "Development:"
	@echo "  make dev         - Run locally with Python venv"
	@echo "  make build-run   - Clean, build, and run with logs"
	@echo "  make test        - Run tests in container"
	@echo "  make lint        - Run linters"
	@echo "  make format      - Format code with black"
	@echo ""
	@echo "Cleaning:"
	@echo "  make clean       - Remove containers, volumes, and images"
	@echo ""
	@echo "OpenShift Operations:"
	@echo "  make oc-help     - Show OpenShift-specific commands"
	@echo "  make oc-check    - Verify OpenShift login and prerequisites"
	@echo "  make oc-deploy   - Deploy to OpenShift (automated script)"
	@echo "  make oc-build    - Rebuild image in OpenShift"
	@echo "  make oc-clean    - Delete all OpenShift resources"
	@echo "  make oc-rebuild  - Clean and redeploy to OpenShift"
	@echo "  make oc-status   - Show status of all resources"
	@echo "  make oc-verify   - Run verification steps"
	@echo "  make oc-logs     - Show application logs"
	@echo "  make oc-url      - Get application URL"
	@echo ""
	@echo "Helm Operations:"
	@echo "  make helm-help       - Show Helm-specific commands"
	@echo "  make helm-check      - Check Helm installation"
	@echo "  make helm-lint       - Lint Helm chart"
	@echo "  make helm-template   - Render Helm templates"
	@echo "  make helm-install    - Install Helm chart"
	@echo "  make helm-upgrade    - Upgrade Helm release"
	@echo "  make helm-uninstall  - Uninstall Helm release"
	@echo ""
	@echo "Using: $(COMPOSE_CMD) and $(CONTAINER_CMD)"

# Setup environment
setup: env venv install
	@echo "‚úÖ Setup complete!"
	@echo ""
	@echo "Next steps:"
	@echo "1. Edit .env file with your LiteMAAS API key"
	@echo "2. Run 'make build' to build the container"
	@echo "3. Run 'make up' to start the application"

# Create .env file from template
env:
	@if [ "$(ENV_CHECK)" = "missing" ]; then \
		echo "Creating .env file from template..."; \
		cp .env.template $(ENV_FILE); \
		echo "‚úÖ .env file created. Please edit with your configuration."; \
	else \
		echo ".env file already exists."; \
	fi

# Create Python virtual environment
venv:
	@if [ ! -d "venv" ]; then \
		echo "Creating Python virtual environment..."; \
		python3 -m venv venv; \
		echo "‚úÖ Virtual environment created."; \
		echo "Activate with: source venv/bin/activate"; \
	else \
		echo "Virtual environment already exists."; \
	fi

# Install dependencies in venv
install:
	@if [ -d "venv" ]; then \
		echo "Installing dependencies in virtual environment..."; \
		. venv/bin/activate && pip install --upgrade pip && pip install -r requirements.txt; \
		echo "‚úÖ Dependencies installed."; \
	else \
		echo "‚ùå Virtual environment not found. Run 'make venv' first."; \
		exit 1; \
	fi

# Build container image
build:
	@if [ "$(ENV_CHECK)" = "missing" ]; then \
		echo "‚ùå .env file not found. Run 'make env' first."; \
		exit 1; \
	fi
	@echo "Building container image..."
	$(COMPOSE_CMD) build
	@echo "‚úÖ Build complete!"

# Start container
up:
	@if [ "$(ENV_CHECK)" = "missing" ]; then \
		echo "‚ùå .env file not found. Run 'make env' first."; \
		exit 1; \
	fi
	@echo "Starting container..."
	$(COMPOSE_CMD) up -d
	@echo ""
	@echo "‚úÖ Container started!"
	@echo "üöÄ Application available at: http://localhost:$(PORT)"
	@echo ""
	@echo "View logs with: make logs"

# Stop container
down:
	@echo "Stopping container..."
	$(COMPOSE_CMD) down
	@echo "‚úÖ Container stopped!"

# Restart container
restart: down up

# Show container logs
logs:
	$(COMPOSE_CMD) logs -f

# Open shell in container
shell:
	@echo "Opening shell in container..."
	$(CONTAINER_CMD) exec -it rlteam-mentor-bot /bin/bash

# Check health endpoint
health:
	@echo "Checking application health..."
	@curl -fsS http://localhost:$(PORT)/health | python3 -m json.tool || echo "‚ùå Health check failed"

# Clean everything
clean:
	@echo "Removing containers, volumes, and images..."
	$(COMPOSE_CMD) down -v
	$(CONTAINER_CMD) system prune -f
	@echo "‚úÖ Cleanup complete!"

# Run tests in container
test:
	@echo "Running tests..."
	$(CONTAINER_CMD) exec rlteam-mentor-bot pytest tests/ -v

# Run linters
lint:
	@echo "Running linters..."
	$(CONTAINER_CMD) exec rlteam-mentor-bot flake8 app/ tests/

# Format code
format:
	@echo "Formatting code with black..."
	$(CONTAINER_CMD) exec rlteam-mentor-bot black app/ tests/

# Development mode - run locally with venv
dev:
	@if [ ! -d "venv" ]; then \
		echo "‚ùå Virtual environment not found. Run 'make venv' first."; \
		exit 1; \
	fi
	@if [ "$(ENV_CHECK)" = "missing" ]; then \
		echo "‚ùå .env file not found. Run 'make env' first."; \
		exit 1; \
	fi
	@echo "Starting development server..."
	@echo "Loading environment from .env..."
	@. venv/bin/activate && set -a && . .env && set +a && python3 run.py

# Build and run with logs
build-run: clean build up logs

#########################################
# OpenShift Operations
#########################################

# OpenShift project name (can be overridden)
OC_PROJECT ?= mentor-bot-rlteam
OC_APP_NAME ?= mentor-bot

# OpenShift-specific help
oc-help:
	@echo "======================================"
	@echo "  OpenShift Operations - Detailed Help"
	@echo "======================================"
	@echo ""
	@echo "Prerequisites:"
	@echo "  - oc CLI installed and in PATH"
	@echo "  - Logged into OpenShift cluster"
	@echo "  - LiteMAAS API key available"
	@echo ""
	@echo "Deployment Commands:"
	@echo "  make oc-check    - Verify you're logged into OpenShift"
	@echo "  make oc-deploy   - Deploy using automated script (uses .env)"
	@echo "  make oc-build    - Rebuild image in OpenShift BuildConfig"
	@echo "  make oc-rebuild  - Clean everything and redeploy"
	@echo ""
	@echo "Customization:"
	@echo "  BUILD_STRATEGY=1 make oc-deploy  - Override build strategy"
	@echo "    1 = BuildConfig (in cluster)"
	@echo "    2 = Internal Registry (push local)"
	@echo "    3 = Skip build (use existing)"
	@echo ""
	@echo "Monitoring Commands:"
	@echo "  make oc-status   - Show status of all resources"
	@echo "  make oc-logs     - Follow application logs"
	@echo "  make oc-shell    - Open shell in running pod"
	@echo "  make oc-url      - Get application route URL"
	@echo "  make oc-verify   - Run complete verification checks"
	@echo ""
	@echo "Management Commands:"
	@echo "  make oc-restart  - Restart the deployment"
	@echo "  make oc-scale N=3 - Scale to N replicas"
	@echo "  make oc-clean    - Delete all OpenShift resources"
	@echo ""
	@echo "Manual Verification Steps:"
	@echo "  1. make oc-status      # Check resource status"
	@echo "  2. make oc-logs        # Check application logs"
	@echo "  3. make oc-url         # Get application URL"
	@echo "  4. make oc-verify      # Run all checks"
	@echo ""
	@echo "Current project: $(OC_PROJECT)"
	@echo ""

# Check OpenShift login and prerequisites
oc-check:
	@echo "üîç Checking OpenShift prerequisites..."
	@command -v oc >/dev/null 2>&1 || { echo "‚ùå oc CLI not found. Please install OpenShift CLI."; exit 1; }
	@echo "‚úÖ oc CLI found: $$(oc version --client -o json | grep -o '"gitVersion":"[^"]*' | cut -d'"' -f4)"
	@oc whoami >/dev/null 2>&1 || { echo "‚ùå Not logged into OpenShift. Run: oc login"; exit 1; }
	@echo "‚úÖ Logged in as: $$(oc whoami)"
	@echo "‚úÖ Server: $$(oc whoami --show-server)"
	@echo "‚úÖ Current project: $$(oc project -q 2>/dev/null || echo 'None')"
	@if [ ! -f "Dockerfile" ] && [ -f "Containerfile" ]; then \
		echo "‚ö†Ô∏è  Creating Dockerfile symlink for OpenShift..."; \
		ln -sf Containerfile Dockerfile; \
	fi
	@echo "‚úÖ All prerequisites met!"

# Deploy to OpenShift using automated script
oc-deploy: oc-check
	@echo "üöÄ Deploying to OpenShift..."
	@if [ "$(ENV_CHECK)" = "missing" ]; then \
		echo "‚ùå .env file not found. Run 'make env' first."; \
		exit 1; \
	fi
	@if [ -z "$(LITEMAAS_API_KEY)" ]; then \
		echo "‚ùå LITEMAAS_API_KEY not set in .env file."; \
		exit 1; \
	fi
	@chmod +x openshift-deploy.sh
	@echo "Using configuration from .env file..."
	@OC_PROJECT="$(OC_PROJECT)" \
	 LITEMAAS_API_KEY="$(LITEMAAS_API_KEY)" \
	 BUILD_STRATEGY="$${BUILD_STRATEGY:-1}" \
	 ./openshift-deploy.sh

# Rebuild image in OpenShift
oc-build: oc-check
	@echo "üî® Rebuilding image in OpenShift..."
	@if [ ! -f "Dockerfile" ] && [ -f "Containerfile" ]; then \
		ln -sf Containerfile Dockerfile; \
	fi
	@if oc get bc/$(OC_APP_NAME) >/dev/null 2>&1; then \
		echo "Starting build from local source..."; \
		oc start-build $(OC_APP_NAME) --from-dir=. --follow; \
		echo ""; \
		echo "Updating deployment to use new image..."; \
		PROJECT=$$(oc project -q); \
		oc set image deployment/$(OC_APP_NAME) $(OC_APP_NAME)=image-registry.openshift-image-registry.svc:5000/$$PROJECT/$(OC_APP_NAME):latest; \
	else \
		echo "‚ùå BuildConfig not found. Run 'make oc-deploy' first."; \
		exit 1; \
	fi
	@echo "‚úÖ Image rebuilt and deployment updated!"

# Show status of all OpenShift resources
oc-status: oc-check
	@echo "üìä OpenShift Resource Status"
	@echo "======================================"
	@echo ""
	@echo "Project:"
	@oc project
	@echo ""
	@echo "All Resources:"
	@oc get all
	@echo ""
	@echo "ConfigMaps:"
	@oc get cm -l app=$(OC_APP_NAME)
	@echo ""
	@echo "Secrets:"
	@oc get secret -l app=$(OC_APP_NAME)
	@echo ""
	@echo "Routes:"
	@oc get route -l app=$(OC_APP_NAME)
	@echo ""
	@echo "Recent Events:"
	@oc get events --sort-by='.lastTimestamp' | head -10

# Show application logs
oc-logs: oc-check
	@echo "üìã Following application logs..."
	@echo "Press Ctrl+C to stop"
	@echo ""
	@oc logs -f deployment/$(OC_APP_NAME)

# Open shell in running pod
oc-shell: oc-check
	@echo "üêö Opening shell in pod..."
	@POD=$$(oc get pods -l app=$(OC_APP_NAME) -o name | head -1); \
	if [ -z "$$POD" ]; then \
		echo "‚ùå No running pods found"; \
		exit 1; \
	fi; \
	echo "Connecting to $$POD..."; \
	oc exec -it $$POD -- /bin/bash

# Get application URL
oc-url: oc-check
	@echo "üåê Application URL:"
	@ROUTE_URL=$$(oc get route $(OC_APP_NAME)-route -o jsonpath='{.spec.host}' 2>/dev/null); \
	if [ -z "$$ROUTE_URL" ]; then \
		echo "‚ùå Route not found"; \
		exit 1; \
	fi; \
	echo ""; \
	echo "  https://$$ROUTE_URL"; \
	echo ""; \
	echo "Health Check:"; \
	echo "  curl https://$$ROUTE_URL/health"; \
	echo ""; \
	echo "Chat API:"; \
	echo "  curl -X POST https://$$ROUTE_URL/api/chat \\"; \
	echo "    -H 'Content-Type: application/json' \\"; \
	echo "    -d '{\"message\": \"Hello!\"}'"; \
	echo ""

# Restart the deployment
oc-restart: oc-check
	@echo "‚ôªÔ∏è  Restarting deployment..."
	@oc rollout restart deployment/$(OC_APP_NAME)
	@echo "‚è≥ Waiting for rollout to complete..."
	@oc rollout status deployment/$(OC_APP_NAME)
	@echo "‚úÖ Deployment restarted successfully!"

# Scale the deployment
oc-scale: oc-check
	@if [ -z "$(N)" ]; then \
		echo "‚ùå Please specify number of replicas: make oc-scale N=3"; \
		exit 1; \
	fi
	@echo "‚öñÔ∏è  Scaling to $(N) replicas..."
	@oc scale deployment/$(OC_APP_NAME) --replicas=$(N)
	@echo "‚úÖ Scaled to $(N) replicas"
	@oc get pods -l app=$(OC_APP_NAME)

# Run complete verification
oc-verify: oc-check
	@echo "‚úÖ Running OpenShift Deployment Verification"
	@echo "======================================"
	@echo ""
	@echo "1Ô∏è‚É£  Checking Project..."
	@oc project
	@echo ""
	@echo "2Ô∏è‚É£  Checking Pods..."
	@POD_STATUS=$$(oc get pods -l app=$(OC_APP_NAME) -o jsonpath='{.items[0].status.phase}' 2>/dev/null); \
	if [ "$$POD_STATUS" = "Running" ]; then \
		echo "‚úÖ Pod is running"; \
		oc get pods -l app=$(OC_APP_NAME); \
	else \
		echo "‚ùå Pod status: $$POD_STATUS"; \
		oc get pods -l app=$(OC_APP_NAME); \
		exit 1; \
	fi
	@echo ""
	@echo "3Ô∏è‚É£  Checking Service..."
	@if oc get svc $(OC_APP_NAME)-service >/dev/null 2>&1; then \
		echo "‚úÖ Service exists"; \
		oc get svc $(OC_APP_NAME)-service; \
	else \
		echo "‚ùå Service not found"; \
		exit 1; \
	fi
	@echo ""
	@echo "4Ô∏è‚É£  Checking Route..."
	@ROUTE_URL=$$(oc get route $(OC_APP_NAME)-route -o jsonpath='{.spec.host}' 2>/dev/null); \
	if [ -n "$$ROUTE_URL" ]; then \
		echo "‚úÖ Route exists: https://$$ROUTE_URL"; \
	else \
		echo "‚ùå Route not found"; \
		exit 1; \
	fi
	@echo ""
	@echo "5Ô∏è‚É£  Checking Health Endpoint..."
	@ROUTE_URL=$$(oc get route $(OC_APP_NAME)-route -o jsonpath='{.spec.host}'); \
	if curl -fsS --max-time 10 "https://$$ROUTE_URL/health" >/dev/null 2>&1; then \
		echo "‚úÖ Health endpoint responding"; \
		curl -s "https://$$ROUTE_URL/health" | python3 -m json.tool; \
	else \
		echo "‚ùå Health endpoint not responding"; \
		echo "Checking pod logs..."; \
		oc logs -l app=$(OC_APP_NAME) --tail=20; \
		exit 1; \
	fi
	@echo ""
	@echo "6Ô∏è‚É£  Checking ConfigMap..."
	@if oc get cm $(OC_APP_NAME)-config >/dev/null 2>&1; then \
		echo "‚úÖ ConfigMap exists"; \
	else \
		echo "‚ùå ConfigMap not found"; \
		exit 1; \
	fi
	@echo ""
	@echo "7Ô∏è‚É£  Checking Secrets..."
	@if oc get secret $(OC_APP_NAME)-secrets >/dev/null 2>&1; then \
		echo "‚úÖ Secrets exist"; \
	else \
		echo "‚ùå Secrets not found"; \
		exit 1; \
	fi
	@echo ""
	@echo "8Ô∏è‚É£  Checking ServiceAccount..."
	@if oc get sa $(OC_APP_NAME)-sa >/dev/null 2>&1; then \
		echo "‚úÖ ServiceAccount exists"; \
	else \
		echo "‚ö†Ô∏è  ServiceAccount not found (optional)"; \
	fi
	@echo ""
	@echo "9Ô∏è‚É£  Testing Chat API..."
	@ROUTE_URL=$$(oc get route $(OC_APP_NAME)-route -o jsonpath='{.spec.host}'); \
	RESPONSE=$$(curl -fsS --max-time 30 -X POST "https://$$ROUTE_URL/api/chat" \
		-H 'Content-Type: application/json' \
		-d '{"message": "Hello"}' 2>/dev/null); \
	if [ $$? -eq 0 ]; then \
		echo "‚úÖ Chat API responding"; \
		echo "$$RESPONSE" | python3 -m json.tool | head -5; \
	else \
		echo "‚ùå Chat API not responding"; \
		exit 1; \
	fi
	@echo ""
	@echo "üîü  Checking Resource Usage..."
	@if oc adm top pods -l app=$(OC_APP_NAME) >/dev/null 2>&1; then \
		oc adm top pods -l app=$(OC_APP_NAME); \
	else \
		echo "‚ö†Ô∏è  Metrics not available (metrics server may not be running)"; \
	fi
	@echo ""
	@echo "======================================"
	@echo "‚úÖ All verification checks passed!"
	@echo "======================================"
	@echo ""
	@echo "Application URL: https://$$(oc get route $(OC_APP_NAME)-route -o jsonpath='{.spec.host}')"
	@echo ""

# Clean all OpenShift resources
oc-clean: oc-check
	@echo "üóëÔ∏è  Cleaning OpenShift resources..."
	@echo "‚ö†Ô∏è  This will delete all resources in the current project"
	@echo "Project: $$(oc project -q)"
	@read -p "Are you sure? [y/N] " -n 1 -r; \
	echo; \
	if [[ $$REPLY =~ ^[Yy]$$ ]]; then \
		echo "Deleting resources..."; \
		oc delete all,cm,secret,route,sa -l app=$(OC_APP_NAME) 2>/dev/null || true; \
		oc delete secret mentor-bot-secrets 2>/dev/null || true; \
		oc delete bc/$(OC_APP_NAME) 2>/dev/null || true; \
		oc delete is/$(OC_APP_NAME) 2>/dev/null || true; \
		echo "‚úÖ Resources deleted"; \
	else \
		echo "‚ùå Cancelled"; \
	fi

# Clean and rebuild everything
oc-rebuild: oc-clean oc-deploy
	@echo "‚úÖ Rebuild complete!"

#########################################
# Helm Operations
#########################################

# Helm configuration
HELM_CHART_PATH := ./helm/mentor-bot
HELM_RELEASE_NAME ?= mentor-bot
HELM_NAMESPACE ?= mentor-bot-rlteam
HELM_VALUES_FILE := $(HELM_CHART_PATH)/values.yaml
HELM_OPENSHIFT_VALUES := $(HELM_CHART_PATH)/values-openshift.yaml

# Helm-specific help
helm-help:
	@echo "======================================"
	@echo "  Helm Operations - Detailed Help"
	@echo "======================================"
	@echo ""
	@echo "Prerequisites:"
	@echo "  - helm CLI installed (v3.0+)"
	@echo "  - oc or kubectl configured"
	@echo "  - LiteMAAS API key available"
	@echo ""
	@echo "Chart Management:"
	@echo "  make helm-check      - Verify Helm installation"
	@echo "  make helm-lint       - Validate chart syntax and structure"
	@echo "  make helm-template   - Render templates without installing"
	@echo "  make helm-package    - Package chart into archive"
	@echo ""
	@echo "Deployment:"
	@echo "  make helm-install    - Install chart (OpenShift optimized)"
	@echo "  make helm-upgrade    - Upgrade existing release"
	@echo "  make helm-uninstall  - Remove Helm release"
	@echo ""
	@echo "Customization:"
	@echo "  HELM_RELEASE_NAME=my-bot make helm-install"
	@echo "  HELM_NAMESPACE=production make helm-install"
	@echo "  API_KEY=sk-xxx make helm-install"
	@echo ""
	@echo "Monitoring:"
	@echo "  make helm-list       - List all Helm releases"
	@echo "  make helm-status     - Show release status"
	@echo "  make helm-get-values - Show current values"
	@echo "  make helm-history    - Show release history"
	@echo "  make helm-test       - Run chart tests"
	@echo ""
	@echo "Development:"
	@echo "  make helm-debug      - Install with debug output"
	@echo "  make helm-diff       - Show diff before upgrade"
	@echo "  make helm-rollback   - Rollback to previous version"
	@echo ""
	@echo "Current settings:"
	@echo "  Chart:     $(HELM_CHART_PATH)"
	@echo "  Release:   $(HELM_RELEASE_NAME)"
	@echo "  Namespace: $(HELM_NAMESPACE)"
	@echo ""

# Check Helm installation
helm-check:
	@echo "üîç Checking Helm installation..."
	@command -v helm >/dev/null 2>&1 || { echo "‚ùå helm CLI not found. Please install Helm."; exit 1; }
	@echo "‚úÖ Helm version: $$(helm version --short)"
	@command -v oc >/dev/null 2>&1 && echo "‚úÖ oc CLI found: $$(oc version --client --short 2>/dev/null || echo 'version unknown')" || true
	@command -v kubectl >/dev/null 2>&1 && echo "‚úÖ kubectl found: $$(kubectl version --client --short 2>/dev/null || echo 'version unknown')" || true
	@echo "‚úÖ Chart location: $(HELM_CHART_PATH)"
	@test -f "$(HELM_CHART_PATH)/Chart.yaml" || { echo "‚ùå Chart.yaml not found"; exit 1; }
	@echo "‚úÖ Chart.yaml found"
	@echo "‚úÖ All prerequisites met!"

# Lint Helm chart
helm-lint: helm-check
	@echo "üîç Linting Helm chart..."
	@helm lint $(HELM_CHART_PATH)
	@echo "‚úÖ Chart validation passed!"

# Render Helm templates
helm-template: helm-check
	@echo "üìÑ Rendering Helm templates..."
	@helm template $(HELM_RELEASE_NAME) $(HELM_CHART_PATH) \
		-f $(HELM_OPENSHIFT_VALUES) \
		--namespace $(HELM_NAMESPACE)

# Render templates with custom API key
helm-template-with-key: helm-check
	@if [ -z "$(API_KEY)" ]; then \
		echo "‚ùå API_KEY not set. Usage: API_KEY=your-key make helm-template-with-key"; \
		exit 1; \
	fi
	@echo "üìÑ Rendering Helm templates with custom API key..."
	@helm template $(HELM_RELEASE_NAME) $(HELM_CHART_PATH) \
		-f $(HELM_OPENSHIFT_VALUES) \
		--set secrets.data.LITEMAAS_API_KEY="$(API_KEY)" \
		--namespace $(HELM_NAMESPACE)

# Package Helm chart
helm-package: helm-check helm-lint
	@echo "üì¶ Packaging Helm chart..."
	@helm package $(HELM_CHART_PATH) -d ./dist
	@echo "‚úÖ Chart packaged successfully!"

# Install Helm chart (OpenShift)
helm-install: helm-check helm-lint
	@echo "üöÄ Installing Helm chart to OpenShift..."
	@if [ -z "$(API_KEY)" ]; then \
		if [ -z "$(LITEMAAS_API_KEY)" ]; then \
			echo "‚ùå API key not set. Please set API_KEY or LITEMAAS_API_KEY"; \
			echo "Usage: API_KEY=your-key make helm-install"; \
			exit 1; \
		else \
			API_KEY="$(LITEMAAS_API_KEY)"; \
		fi; \
	fi; \
	if ! oc get project $(HELM_NAMESPACE) >/dev/null 2>&1; then \
		echo "Creating namespace $(HELM_NAMESPACE)..."; \
		oc new-project $(HELM_NAMESPACE); \
	fi; \
	helm install $(HELM_RELEASE_NAME) $(HELM_CHART_PATH) \
		-f $(HELM_OPENSHIFT_VALUES) \
		--set secrets.data.LITEMAAS_API_KEY="$$API_KEY" \
		--namespace $(HELM_NAMESPACE) \
		--create-namespace
	@echo "‚úÖ Helm chart installed successfully!"

# Upgrade Helm release
helm-upgrade: helm-check helm-lint
	@echo "‚¨ÜÔ∏è  Upgrading Helm release..."
	@if [ -n "$(API_KEY)" ]; then \
		helm upgrade $(HELM_RELEASE_NAME) $(HELM_CHART_PATH) \
			-f $(HELM_OPENSHIFT_VALUES) \
			--set secrets.data.LITEMAAS_API_KEY="$(API_KEY)" \
			--namespace $(HELM_NAMESPACE); \
	else \
		helm upgrade $(HELM_RELEASE_NAME) $(HELM_CHART_PATH) \
			-f $(HELM_OPENSHIFT_VALUES) \
			--namespace $(HELM_NAMESPACE); \
	fi
	@echo "‚úÖ Helm release upgraded successfully!"

# Uninstall Helm release
helm-uninstall: helm-check
	@echo "üóëÔ∏è  Uninstalling Helm release..."
	@helm uninstall $(HELM_RELEASE_NAME) --namespace $(HELM_NAMESPACE)
	@echo "‚úÖ Helm release uninstalled!"

# List Helm releases
helm-list: helm-check
	@echo "üìã Helm releases:"
	@helm list --namespace $(HELM_NAMESPACE)

# Show Helm release status
helm-status: helm-check
	@echo "üìä Release status:"
	@helm status $(HELM_RELEASE_NAME) --namespace $(HELM_NAMESPACE)

# Get current values
helm-get-values: helm-check
	@echo "‚öôÔ∏è  Current Helm values:"
	@helm get values $(HELM_RELEASE_NAME) --namespace $(HELM_NAMESPACE)

# Show release history
helm-history: helm-check
	@echo "üìú Release history:"
	@helm history $(HELM_RELEASE_NAME) --namespace $(HELM_NAMESPACE)

# Run Helm tests
helm-test: helm-check
	@echo "üß™ Running Helm tests..."
	@helm test $(HELM_RELEASE_NAME) --namespace $(HELM_NAMESPACE)

# Install with debug
helm-debug: helm-check helm-lint
	@echo "üêõ Installing with debug output..."
	@helm install $(HELM_RELEASE_NAME) $(HELM_CHART_PATH) \
		-f $(HELM_OPENSHIFT_VALUES) \
		--namespace $(HELM_NAMESPACE) \
		--debug \
		--dry-run

# Show diff before upgrade
helm-diff: helm-check
	@echo "üîç Showing diff..."
	@command -v helm-diff >/dev/null 2>&1 || { echo "‚ùå helm-diff plugin not installed. Run: helm plugin install https://github.com/databus23/helm-diff"; exit 1; }
	@helm diff upgrade $(HELM_RELEASE_NAME) $(HELM_CHART_PATH) \
		-f $(HELM_OPENSHIFT_VALUES) \
		--namespace $(HELM_NAMESPACE)

# Rollback to previous version
helm-rollback: helm-check
	@echo "‚è™ Rolling back to previous version..."
	@helm rollback $(HELM_RELEASE_NAME) --namespace $(HELM_NAMESPACE)
	@echo "‚úÖ Rollback complete!"

# Get application URL (OpenShift)
helm-url: helm-check
	@echo "üåê Application URL:"
	@ROUTE_URL=$$(oc get route $(HELM_RELEASE_NAME)-route -n $(HELM_NAMESPACE) -o jsonpath='{.spec.host}' 2>/dev/null); \
	if [ -z "$$ROUTE_URL" ]; then \
		echo "‚ùå Route not found"; \
		exit 1; \
	fi; \
	echo ""; \
	echo "  https://$$ROUTE_URL"; \
	echo ""; \
	echo "Health Check:"; \
	echo "  curl https://$$ROUTE_URL/health"
